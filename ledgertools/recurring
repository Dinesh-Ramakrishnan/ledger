#!/usr/bin/env python
"""
recurring [01..31|all [01..12]] 
Simon Michael 2008

With no arguments, prints any recurring ledger entries due today, ready
for adding to a ledger file. The idea is to call this once a day to add
predictable transactions to your ledger, keeping it more current and
reducing effort at reconcile time.

With a day number or all, print entries for that day, or all entries.
With a month number, print entries dated for that month. These are
useful for manual catch-up.

Here is an example crontab line: "0 0 * * * user recurring >>LEDGERFILE".
On a mac, add "recurring >>LEDGERFILE" to /etc/daily.local instead.
(laptop users: this will get called just once on waking from a multi-day
sleep and not at all for powered-off days, so you might need to catch up.)

Recurring entries are configured below, grouped by day of the month.
Each is a list of arguments to the ledger entry command. It uses the
most recent similar entry as a template, so usually the payee is enough,
but you might also want to set the amount.  I use .99 as a memo for
"approximate, adjust me later".
"""

ENTRIES = {
    1:[['savings deposit'],
       ['blue cross'],
       ],
    6:[['slicehost'],
       ],
    15:[['edison',15.99],
        ['gas',12.99],
        ],
    }

import sys, os, optparse
from datetime import date

parser = optparse.OptionParser()
opts,args = parser.parse_args()
today = date.today()
year  = today.year
month = len(args)>1 and int(args[1]) or today.month
day   = len(args)>0 and args[0] or today.day
if day != 'all': day = int(day)

def print_entry(y,m,d,*args):
    os.system('ledger entry %s/%s/%s %s' % (y,m,d,' '.join(['"%s"'%a for a in args])))

if day == 'all':
    for d,ts in sorted(ENTRIES.items()):
        for t in ts: print_entry(year,month,d,*t)
else:
    for t in ENTRIES.get(day,[]): print_entry(year,month,day,*t)
